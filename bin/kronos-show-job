#!/usr/bin/env python
# (C) Copyright 1996-2017 ECMWF.
#
# This software is licensed under the terms of the Apache Licence Version 2.0
# which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
# In applying this licence, ECMWF does not waive the privileges and immunities
# granted to it by virtue of its status as an intergovernmental organisation nor
# does it submit to any jurisdiction.

"""

=======================
show info of a KSF file
=======================

"""

import sys
import json
import argparse

from kronos.io.schedule_format import ScheduleFormat
from kronos.core.time_signal.definitions import time_signal_names, signal_types


def get_tot_metrics(synth_app):
    """
    Return the dictionary with the metrics totals..
    :return:
    """

    metrics_names = time_signal_names + ["n_mkdir"]

    app_metrics = {k: [] for k in metrics_names}

    for frame in synth_app["frames"]:

        for ker in frame:

            if ker["name"] == "cpu":
                app_metrics["flops"].append(signal_types["flops"]["type"](ker["flops"]))

            elif ker["name"] == "file-read":
                app_metrics["kb_read"].append(signal_types["kb_read"]["type"](ker["kb_read"]))
                app_metrics["n_read"].append(signal_types["n_read"]["type"](ker["n_read"]))

            elif ker["name"] == "file-write":
                app_metrics["kb_write"].append(signal_types["kb_write"]["type"](ker["kb_write"]))
                app_metrics["n_write"].append(signal_types["n_write"]["type"](ker["n_write"]))

            elif ker["name"] == "mpi":
                app_metrics["n_pairwise"].append(
                    signal_types["n_pairwise"]["type"](ker["n_pairwise"]) * synth_app["num_procs"])
                app_metrics["kb_pairwise"].append(
                    signal_types["kb_pairwise"]["type"](ker["kb_pairwise"]) * synth_app["num_procs"])
                app_metrics["n_collective"].append(
                    signal_types["n_collective"]["type"](ker["n_collective"]) * synth_app["num_procs"])
                app_metrics["kb_collective"].append(
                    signal_types["kb_collective"]["type"](ker["kb_collective"]) * synth_app["num_procs"])

            # --------- additional kernels --------
            elif ker["name"] == "fs_metadata":
                app_metrics["n_mkdir"].append(int(ker["n_mkdir"]))

            else:
                raise ("kernel name {} not recognized!".format(ker["name"]))

    # finally return the sums
    return {name: sum(metrics) for name, metrics in app_metrics.iteritems()}

if __name__ == "__main__":

    # Parser for the required arguments
    parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument("ksf", type=str, help="File name of KSF to inspect")
    parser.add_argument("label", type=str, help="label of the synthetic app to show")

    # print the help if no arguments are passed
    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    # parse the arguments..
    args = parser.parse_args()

    ksf_data = ScheduleFormat.from_filename(args.ksf).synapp_data

    synth_app_json_data = []
    for app in ksf_data:

        if args.label in app["metadata"]["workload_name"]:
            synth_app_json_data.append(app)

    if not synth_app_json_data:
        print "synthetic app not found in KSF"
        sys.exit(1)

    if len(synth_app_json_data) > 1:
        print "N={} matching synthetic-apps found!".format(len(synth_app_json_data))

        for app in synth_app_json_data:

            print "Synthetic App: {}".format(app["metadata"]["workload_name"])
            print "---------- RAW DATA ------------"
            print json.dumps(synth_app_json_data[0], sort_keys=True, indent=4, separators=(',', ': '))

            print "---------- TOTALS --------------"
            print json.dumps(get_tot_metrics(synth_app_json_data[0]), sort_keys=True, indent=4, separators=(',', ': '))


