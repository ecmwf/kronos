#!/usr/bin/env python
# (C) Copyright 1996-2017 ECMWF.
#
# This software is licensed under the terms of the Apache Licence Version 2.0
# which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
# In applying this licence, ECMWF does not waive the privileges and immunities
# granted to it by virtue of its status as an intergovernmental organisation nor
# does it submit to any jurisdiction.

"""
show info of a KSF file
"""

import argparse
from collections import OrderedDict

from kronos.executor.tools import mean_of_list, std_of_list
from kronos.io.profile_format import ProfileFormat
from kronos.io.schedule_format import ScheduleFormat


# TODO: any shared config should go into a global place, signal_types is repeated here
# TODO: to avoid loading a module from "core" library

# The availably types of time-series (or summed/averaged totals) data that we can use
signal_types = OrderedDict([

    # # CPU
    ('flops',    {'type': int,   'category': 'cpu',        'behaviour': 'sum'}),

    # (file) I/O
    ('kb_read',  {'type': float, 'category': 'file-read',  'behaviour': 'sum'}),
    ('kb_write', {'type': float, 'category': 'file-write', 'behaviour': 'sum'}),
    ('n_read',   {'type': int,   'category': 'file-read',  'behaviour': 'sum'}),
    ('n_write',  {'type': int,   'category': 'file-write', 'behaviour': 'sum'}),

    # MPI activity
    ('n_pairwise',    {'type': int,   'category': 'mpi',  'behaviour': 'sum'}),
    ('kb_pairwise',   {'type': float, 'category': 'mpi',  'behaviour': 'sum'}),
    ('n_collective',  {'type': int,   'category': 'mpi',  'behaviour': 'sum'}),
    ('kb_collective', {'type': float, 'category': 'mpi',  'behaviour': 'sum'})
])


# add print info
float_format_print = '%16.3f'
int_format_print = '%16.0f'

signal_types['flops']["print_info"] = {"unit": "Gflops", "format": int_format_print, "conv": 1.0/(1024.0**3)}

signal_types['kb_read']["print_info"] = {"unit": "Gbytes", "format": float_format_print, "conv": 1.0/(1024.0**2)}
signal_types['kb_write']["print_info"] = {"unit": "Gbytes", "format": float_format_print, "conv": 1.0/(1024.0**2)}
signal_types['n_read']["print_info"] = {"unit": "times ", "format": int_format_print, "conv": 1.0}
signal_types['n_write']["print_info"] = {"unit": "times ", "format": int_format_print, "conv": 1.0}

signal_types['n_pairwise']["print_info"] = {"unit": "times ", "format": int_format_print, "conv": 1.0}
signal_types['kb_pairwise']["print_info"] = {"unit": "Gbytes", "format": float_format_print, "conv": 1.0/(1024.0**2)}
signal_types['n_collective']["print_info"] = {"unit": "times ", "format": int_format_print, "conv": 1.0}
signal_types['kb_collective']["print_info"] = {"unit": "Gbytes", "format": float_format_print, "conv": 1.0/(1024.0**2)}


time_signal_names = signal_types.keys()


def factory(args):

    """
    A simple factory that returns the appropriate class of file info
    :param args:
    :return:
    """

    if args.ksf:

        return ksf_info(ScheduleFormat.from_filename(args.ksf).synapp_data)

    elif args.kpf:

        return kpf_info(ProfileFormat.from_filename(args.kpf).profiled_jobs)
    else:
        raise Exception("no valid option passed. Type --help for info and options")


class file_info(object):

    metrics_names = time_signal_names

    def __init__(self, jobs_data):

        # Collect all the metrics names to display..
        self.tot_metrics = {k: [] for k in self.metrics_names}

        self.jobs_data = jobs_data

    def n_apps(self):
        return -1

    def get_tot_metrics(self):
        pass


class ksf_info(file_info):

    metrics_names = time_signal_names + ["n_mkdir"]

    def __init__(self, jobs_data):

        super(ksf_info, self).__init__(jobs_data)

    def n_procs(self):
        return [app["num_procs"] for app in self.jobs_data]

    def start_delay(self):
        return [app["start_delay"] for app in self.jobs_data]

    def get_tot_metrics(self):
        """
        Return the dictionary with the metrics totals..
        :return:
        """

        print self.metrics_names

        for synth_app in self.jobs_data:

            app_metrics = {k: [] for k in self.metrics_names}

            for frame in synth_app["frames"]:

                for ker in frame:

                    if ker["name"] == "cpu":
                        app_metrics["flops"].append(signal_types["flops"]["type"](ker["flops"]))

                    elif ker["name"] == "file-read":
                        app_metrics["kb_read"].append(signal_types["kb_read"]["type"](ker["kb_read"]))
                        app_metrics["n_read"].append(signal_types["n_read"]["type"](ker["n_read"]))

                    elif ker["name"] == "file-write":
                        app_metrics["kb_write"].append(signal_types["kb_write"]["type"](ker["kb_write"]))
                        app_metrics["n_write"].append(signal_types["n_write"]["type"](ker["n_write"]))

                    elif ker["name"] == "mpi":
                        app_metrics["n_pairwise"].append(signal_types["n_pairwise"]["type"](ker["n_pairwise"]))
                        app_metrics["kb_pairwise"].append(signal_types["kb_pairwise"]["type"](ker["kb_pairwise"]))
                        app_metrics["n_collective"].append(signal_types["n_collective"]["type"](ker["n_collective"]))
                        app_metrics["kb_collective"].append(signal_types["kb_collective"]["type"](ker["kb_collective"]))

                    # ------------ additional kernels --------
                    elif ker["name"] == "fs_metadata":
                        app_metrics["n_mkdir"].append(int(ker["n_mkdir"]))

                    else:
                        raise ("kernel name {} not recognized!".format(ker["name"]))

            # append synth app sums into totats
            for k in app_metrics.keys():
                self.tot_metrics[k].append(sum(app_metrics[k]))

        return self.tot_metrics


class kpf_info(file_info):

    def __init__(self, jobs_data):

        super(kpf_info, self).__init__(jobs_data)

    def n_procs(self):
        return [app["ncpus"] for app in self.jobs_data if app.get("ncpus")]

    def start_delay(self):
        delay_vec = [app["time_start"] for app in self.jobs_data]
        delay_vec = delay_vec - min(delay_vec)
        return delay_vec

    def get_tot_metrics(self):
        """
        Return the dictionary with the metrics totals..
        :return:
        """

        for job in self.jobs_data:

            for ts in signal_types:
                if job.get("time_series"):
                    if ts in job["time_series"].keys():
                        self.tot_metrics[ts].append(sum(job["time_series"][ts]["values"]))

        return self.tot_metrics


def print_qty_header():
    """
    Print a header
    :return:
    """
    _str = ""
    _str += "-" * 143
    _str += "\n"
    _str += "       qty        |"
    _str += "           sum          |"
    _str += "           avg          |"
    _str += "           min          |"
    _str += "           max          |"
    _str += "           std         |"
    _str += "\n"
    _str += "-" * 143
    return _str


def print_one_liner_qty(qty_vec, qty_name):
    """
    Print one-line quantities
    :param qty_vec:
    :param qty_name:
    :return:
    """
    _str = ""

    if qty_vec:
        _str += "{:17s}:{:>25s}{:>25.2f}{:>25.0f}{:>25.0f}{:>25.2f}".format(qty_name,
                                                                            "N/A",
                                                                            mean_of_list(qty_vec),
                                                                            min(qty_vec),
                                                                            max(qty_vec),
                                                                            std_of_list(qty_vec)
                                                                            )
    else:
        _str += "{:17s}:{:>25s}{:>25s}{:>25s}{:>25s}{:>25s}".format(qty_name,
                                                                    "N/A",
                                                                    "vector empty!",
                                                                    "vector empty!",
                                                                    "vector empty!",
                                                                    "vector empty!"
                                                                    )
    return _str


def print_metrics(tot_metrics):
    """
    Print tot of metrics
    :param tot_metrics:
    :return:
    """

    _str = ""

    for name in time_signal_names:

        if tot_metrics[name]:
            unit = signal_types[name]["print_info"]["unit"]
            form = signal_types[name]["print_info"]["format"]
            conv = signal_types[name]["print_info"]["conv"]
            str_format = "%-17s:"
            str_format += form + " [" + unit + "]"
            str_format += form + " [" + unit + "]"
            str_format += form + " [" + unit + "]"
            str_format += form + " [" + unit + "]"
            str_format += form + " [" + unit + "]"
            _str += str_format % (name,
                                sum(tot_metrics[name]) * conv,
                                mean_of_list(tot_metrics[name]) * conv,
                                min(tot_metrics[name]) * conv,
                                max(tot_metrics[name]) * conv,
                                std_of_list(tot_metrics[name]) * conv)
        else:
            _str += "{:17s}:{:>25s}{:>25s}{:>25s}{:>25s}{:>25s}".format(name,
                                                                        "vector empty!",
                                                                        "vector empty!",
                                                                        "vector empty!",
                                                                        "vector empty!",
                                                                        "vector empty!"
                                                                        )
        _str += "\n"

    return _str


if __name__ == "__main__":

    # Parser for the required arguments
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--ksf", type=str, help="File name of KSF to inspect")
    parser.add_argument("--kpf", type=str, help="File name of KSF of the corresponding kronos run")
    args = parser.parse_args()

    info = factory(args)
    n_proc_vec = info.n_procs()
    start_delay_vec = info.start_delay()
    tot_metrics = info.get_tot_metrics()

    # print summary
    print "\nSUMMARY:"
    print "N apps: {}".format(len(info.jobs_data))

    print "\nJOB STATS:"
    print print_qty_header()
    print print_one_liner_qty(n_proc_vec, "Nprocs")
    print print_one_liner_qty(start_delay_vec, "start_delay")

    print "\nMETRICS:"
    print print_qty_header()
    print print_metrics(tot_metrics)

    print "\n..done"