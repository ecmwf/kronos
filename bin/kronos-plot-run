#!/usr/bin/env python2.7
# (C) Copyright 1996-2017 ECMWF.
# 
# This software is licensed under the terms of the Apache Licence Version 2.0
# which can be obtained at http://www.apache.org/licenses/LICENSE-2.0. 
# In applying this licence, ECMWF does not waive the privileges and immunities 
# granted to it by virtue of its status as an intergovernmental organisation nor
# does it submit to any jurisdiction.

"""
Kronos tool to quickly inspect the results of a run
"""

import argparse
import sys
import os
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.pyplot import cm

sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from kronos.core.plot_handler import PlotHandler
from kronos.core.workload_data import WorkloadData, WorkloadDataGroup
from kronos.io.profile_format import ProfileFormat


if __name__ == "__main__":

    # Parser for the required arguments
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("path_model_kpf", type=str, help="The path of the KPF file to read")
    parser.add_argument("path_unmodelled_kpf", help="path of KPF file of un-modelled data to over-plot")
    parser.add_argument("-p", "--plot", action="store_true", help="plot the output of the run")
    args = parser.parse_args()

    # retrieve kpf data from model run
    kpf_workload = WorkloadData.from_kpf(ProfileFormat.from_filename(args.path_model_kpf))
    n_apps = len(kpf_workload.jobs)
    wl_model_group = kpf_workload.group_by_job_labels

    # retrieve information from KPF of original workloads
    wl_orig_group = WorkloadDataGroup.from_pickled(args.path_unmodelled_kpf)

    if args.plot:

        plt_hdl = PlotHandler()
        color = iter(cm.rainbow(np.linspace(0, 1, len(wl_model_group.tags))))
        n_plots = len(kpf_workload.total_metrics_timesignals.keys()) + 2
        fig_size = (18, 3 * n_plots)
        plt.figure(plt_hdl.get_fig_handle_ID(), figsize=fig_size)
        id_plot = 0

        for ll, label in enumerate(wl_model_group.tags):

            # ------- retrieve kpf data from iteration ----------
            kpf_workload = wl_model_group.get_workload_by_name(label)
            _, n_running_vec = kpf_workload.running_jobs
            time_stamps, nproc_running_vec = kpf_workload.running_cpus

            # ----- retrieve jobs fro the original workload.. -----
            kpf_workload_orig = wl_orig_group.get_workload_by_name(label)
            kpf_workload_orig_ts_max = wl_orig_group.max_timeseries
            _, n_running_vec_orig = kpf_workload_orig.running_jobs
            time_stamps_orig, nproc_running_vec_orig = kpf_workload_orig.running_cpus

            # ------------------ plots ----------------------------
            line_color = next(color)

            id_plot = 1
            plt.subplot(n_plots, 1, id_plot)
            plt.subplots_adjust(left=0.2, right=0.8, top=0.9, bottom=0.1)

            plt.plot((time_stamps-min(time_stamps))/float(max(time_stamps)-min(time_stamps)),
                     n_running_vec/float(wl_model_group.max_running_jobs),
                     color=line_color, label=label)

            plt.plot((time_stamps_orig-min(time_stamps_orig))/float(max(time_stamps_orig)-min(time_stamps_orig)),
                     n_running_vec_orig/float(wl_orig_group.max_running_jobs),
                     color=line_color, linestyle='--', label=label+"-orig")

            plt.ylabel('#jobs')
            plt.xlim(xmin=0, xmax=1)
            plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))
            plt.title('Time profiles, Number of apps: {}'.format(n_apps))

            id_plot += 1
            plt.subplot(n_plots, 1, id_plot)
            plt.subplots_adjust(left=0.2, right=0.8, top=0.9, bottom=0.1)

            plt.plot((time_stamps-min(time_stamps))/float(max(time_stamps)-min(time_stamps)),
                     nproc_running_vec/float(wl_model_group.max_running_cpus),
                     color=line_color, label=label)

            plt.plot((time_stamps_orig-min(time_stamps_orig))/float(max(time_stamps_orig)-min(time_stamps_orig)),
                     nproc_running_vec_orig/float(wl_orig_group.max_running_cpus),
                     color=line_color, linestyle='--', label=label)

            plt.ylabel('#procs')
            plt.xlim(xmin=0, xmax=1)

            # plot of the total time-signals
            total_metrics = kpf_workload.total_metrics_timesignals
            for tt, ts_name in enumerate(total_metrics):

                ts = kpf_workload.total_metrics_timesignals[ts_name]
                time_stamps, vals = ts.digitized()
                times_norm = (time_stamps - min(time_stamps)) / float(max(time_stamps) - min(time_stamps))

                ts = kpf_workload_orig.total_metrics_timesignals[ts_name]
                time_stamps_orig, vals_orig = ts.digitized()
                times_norm_orig = (time_stamps_orig - min(time_stamps_orig)) / float(max(time_stamps_orig) - min(time_stamps_orig))
                val_orig_max = kpf_workload_orig_ts_max[ts_name]

                id_plot += 1
                plt.subplot(n_plots, 1, id_plot)
                plt.subplots_adjust(left=0.2, right=0.8, top=0.9, bottom=0.1)

                plt.plot(times_norm,
                         vals/max(vals),
                         color=line_color,
                         label=label)
                plt.plot(times_norm_orig,
                         vals_orig/val_orig_max,
                         color=line_color,
                         label=label)

                plt.ylabel(ts_name)
                plt.xlim(xmin=0, xmax=1)

                if tt == len(total_metrics)-1:
                    plt.xlabel('time')

        plt.show()

    else:
        print "Nothing done! type 'kronos-plot-run -h' for valid options"
