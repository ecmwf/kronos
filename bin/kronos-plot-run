#!/usr/bin/env python2.7
# (C) Copyright 1996-2017 ECMWF.
# 
# This software is licensed under the terms of the Apache Licence Version 2.0
# which can be obtained at http://www.apache.org/licenses/LICENSE-2.0. 
# In applying this licence, ECMWF does not waive the privileges and immunities 
# granted to it by virtue of its status as an intergovernmental organisation nor
# does it submit to any jurisdiction.

"""
Kronos tool to quickly inspect the results of a run
"""

import argparse
import sys
import os
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.pyplot import cm

from kronos.core.time_signal import time_signal_names

sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from kronos.core.plot_handler import PlotHandler
from kronos.core.workload_data import WorkloadData, WorkloadDataGroup
from kronos.io.profile_format import ProfileFormat


if __name__ == "__main__":

    # Parser for the required arguments
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("path_model_kpf", type=str, help="Path of the KPF file to read")
    parser.add_argument("path_unmodelled_pickle", help="Path of pickle file of un-modelled data to over-plot")
    parser.add_argument("--nbins", "-n", help="Number of bins used to discretise the time series")
    args = parser.parse_args()

    # take n_bins or use a default value
    n_bins = args.nbins if args.nbins else 30

    # retrieve kpf data from model run
    kpf_workload = WorkloadData.from_kpf(ProfileFormat.from_filename(args.path_model_kpf))
    n_apps = len(kpf_workload.jobs)
    wl_model_group = kpf_workload.group_by_job_labels
    t0_model = wl_model_group.min_start_time

    # retrieve information from KPF of original workloads
    wl_orig_group = WorkloadDataGroup.from_pickled(args.path_unmodelled_pickle)
    t0_orig = wl_orig_group.min_start_time

    plt_hdl = PlotHandler()
    color = iter(cm.rainbow(np.linspace(0, 1, len(wl_model_group.tags))))
    plt.figure(plt_hdl.get_fig_handle_ID(), figsize=(18, 6))

    # collect all the info before plotting for efficiency reasons..
    plot_info_model = {}
    plot_info_orig = {}
    for ll, label in enumerate(wl_model_group.tags):

        # --------- retrieve kpf data from iteration -------------
        kpf_workload = wl_model_group.get_workload_by_name(label)
        n_jobs_in_group = wl_model_group.sum_jobs
        time_stamps, n_running_vec = kpf_workload.running_jobs
        total_metrics_model = kpf_workload.total_metrics_timesignals

        plot_info_model[label] = {
            "n_jobs_in_group": n_jobs_in_group,
            "times_n_running": (time_stamps, n_running_vec),
            "total_metrics": total_metrics_model,
        }
        # --------------------------------------------------------

        # ------- retrieve jobs fro the original workload.. ------
        kpf_workload_orig = wl_orig_group.get_workload_by_name(label)
        n_jobs_in_group_orig = wl_orig_group.sum_jobs
        time_stamps_orig, n_running_vec_orig = kpf_workload_orig.running_jobs
        total_metrics_original = kpf_workload_orig.total_metrics_timesignals

        plot_info_orig[label] = {
            "n_jobs_in_group": n_jobs_in_group_orig,
            "times_n_running": (time_stamps_orig, n_running_vec_orig),
            "total_metrics": total_metrics_original,
        }
        # --------------------------------------------------------

    for ll, label in enumerate(wl_model_group.tags):

        print "label: {}".format(label)

        # --------- retrieve kpf data from iteration -------------
        n_jobs_in_group = plot_info_model[label]["n_jobs_in_group"]
        time_stamps, n_running_vec = plot_info_model[label]["times_n_running"]

        n_jobs_in_group_orig = plot_info_orig[label]["n_jobs_in_group"]
        time_stamps_orig, n_running_vec_orig = plot_info_orig[label]["times_n_running"]
        # --------------------------------------------------------

        # ------------------ plots ----------------------------
        line_color = next(color)

        plt.subplot(2, 1, 1)
        plt.subplots_adjust(left=0.2, right=0.8, top=0.9, bottom=0.1)
        plt.plot(time_stamps-t0_model, n_running_vec/n_jobs_in_group,
                 color=line_color,
                 linestyle='-',
                 label=label)
        plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))
        plt.ylabel('#jobs/N_jobs - model')
        plt.xlabel('time [s]')

        plt.subplot(2, 1, 2)
        plt.subplots_adjust(left=0.2, right=0.8, top=0.9, bottom=0.1)
        plt.plot(time_stamps_orig-t0_orig, n_running_vec_orig/n_jobs_in_group_orig,
                 color=line_color,
                 linestyle='-')
        plt.ylabel('#jobs/N_jobs - original')
        plt.xlabel('time [s]')

    plt.savefig('n_jobs.png')
    plt.close()

    # plots of the total time-signals
    for tt, ts_name in enumerate(time_signal_names):

        print "plotting metric {}".format(ts_name)

        plt_hdl = PlotHandler()
        color = iter(cm.rainbow(np.linspace(0, 1, len(wl_model_group.tags))))
        plt.figure(plt_hdl.get_fig_handle_ID(), figsize=(18, 6))

        for ll, label in enumerate(wl_model_group.tags):

            total_metrics_model_ts = plot_info_model[label]["total_metrics"].get(ts_name)
            total_metrics_original_ts = plot_info_orig[label]["total_metrics"].get(ts_name)

            line_color = next(color)

            plt.subplot(2, 1, 1)
            plt.subplots_adjust(left=0.2, right=0.8, top=0.9, bottom=0.1)
            if total_metrics_model_ts:
                plt.plot(total_metrics_model_ts.xvalues-t0_model, total_metrics_model_ts.yvalues,
                         color=line_color,
                         label=label)
            plt.ylabel(ts_name+" - model")
            plt.xlabel('time [s]')
            plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))

            plt.subplot(2, 1, 2)
            plt.subplots_adjust(left=0.2, right=0.8, top=0.9, bottom=0.1)
            if total_metrics_original_ts:
                plt.plot(total_metrics_original_ts.xvalues-t0_orig, total_metrics_original_ts.yvalues,
                         color=line_color)
            plt.ylabel(ts_name+" - original")
            plt.xlabel('time [s]')

        plt.savefig(ts_name+'.png')
        plt.close()
