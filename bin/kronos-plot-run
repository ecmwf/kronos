#!/usr/bin/env python2.7
# (C) Copyright 1996-2017 ECMWF.
# 
# This software is licensed under the terms of the Apache Licence Version 2.0
# which can be obtained at http://www.apache.org/licenses/LICENSE-2.0. 
# In applying this licence, ECMWF does not waive the privileges and immunities 
# granted to it by virtue of its status as an intergovernmental organisation nor
# does it submit to any jurisdiction.

"""
Kronos tool to quickly inspect the results of a run
"""

import argparse
import sys
import os
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.pyplot import cm

sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from kronos.core.plot_handler import PlotHandler
from kronos.core.workload_data import WorkloadData, WorkloadDataGroup
from kronos.io.profile_format import ProfileFormat


if __name__ == "__main__":

    # Parser for the required arguments
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("path_model_kpf", type=str, help="The path of the KPF file to read")
    parser.add_argument("path_unmodelled_kpf", help="path of KPF file of un-modelled data to over-plot")
    parser.add_argument("-p", "--plot", action="store_true", help="plot the output of the run")
    args = parser.parse_args()

    n_bins = 30

    # retrieve kpf data from model run
    kpf_workload = WorkloadData.from_kpf(ProfileFormat.from_filename(args.path_model_kpf))
    n_apps = len(kpf_workload.jobs)
    wl_model_group = kpf_workload.group_by_job_labels
    max_running_jobs_model = wl_model_group.max_running_jobs
    max_running_cpus_model = wl_model_group.max_running_cpus
    vals_max_model = wl_model_group.max_timeseries(n_bins=n_bins)
    vals_sum_model = wl_model_group.sum_timeseries

    # retrieve information from KPF of original workloads
    wl_orig_group = WorkloadDataGroup.from_pickled(args.path_unmodelled_kpf)
    max_running_jobs_orig = wl_orig_group.max_running_jobs
    max_running_cpus_orig = wl_orig_group.max_running_cpus
    vals_max_orig = wl_orig_group.max_timeseries(n_bins=n_bins)
    vals_sum_orig = wl_orig_group.sum_timeseries

    if args.plot:

        plt_hdl = PlotHandler()
        color = iter(cm.rainbow(np.linspace(0, 1, len(wl_model_group.tags))))
        n_plots = len(kpf_workload.total_metrics_timesignals.keys()) + 1
        fig_size = (18, 2 * n_plots)
        plt.figure(plt_hdl.get_fig_handle_ID(), figsize=fig_size)
        id_plot = 0

        # plot_info collects plotting info during the iterations, to allow bar over-plotting..
        plot_info = []

        cum_model_vals = {}
        for ll, label in enumerate(wl_model_group.tags):

            print "label: {}".format(label)

            # --------- retrieve kpf data from iteration -------------
            kpf_workload = wl_model_group.get_workload_by_name(label)
            time_stamps, n_running_vec = kpf_workload.running_jobs
            # --------------------------------------------------------

            # ------- retrieve jobs fro the original workload.. ------
            kpf_workload_orig = wl_orig_group.get_workload_by_name(label)
            time_stamps_orig, n_running_vec_orig = kpf_workload_orig.running_jobs
            # --------------------------------------------------------

            # ------------------ plots ----------------------------
            line_color = next(color)
            id_plot = 1
            plt.subplot(n_plots, 1, id_plot)
            plt.subplots_adjust(left=0.2, right=0.8, top=0.9, bottom=0.1)

            plt.plot((time_stamps-min(time_stamps))/float(max(time_stamps)-min(time_stamps)),
                     n_running_vec/float(max_running_jobs_model),
                     color=line_color, linestyle='-', label=label+"-modelled")

            plt.plot((time_stamps_orig-min(time_stamps_orig))/float(max(time_stamps_orig)-min(time_stamps_orig)),
                     n_running_vec_orig/float(max_running_jobs_orig),
                     color=line_color, linestyle='--', label=label+"-profiled")

            plt.ylabel('#jobs')
            plt.xlim(xmin=0, xmax=1)
            plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))
            plt.title('#Synthetic Apps: {}'.format(n_apps))

            # plot of the total time-signals
            total_metrics_model = kpf_workload.total_metrics_timesignals
            total_metrics_original = kpf_workload_orig.total_metrics_timesignals
            dx_bin = 1.0/float(n_bins)
            bar_w = dx_bin/2.5
            bar_offset = bar_w

            plot_dict = {}
            for tt, ts_name in enumerate(total_metrics_model.keys()):
                ts = total_metrics_model[ts_name]
                time_stamps, vals = ts.digitized(n_bins)
                times_norm = (time_stamps - min(time_stamps)) / float(max(time_stamps) - min(time_stamps))

                ts = total_metrics_original[ts_name]
                time_stamps_orig, vals_orig = ts.digitized(n_bins)
                times_norm_orig = (time_stamps_orig - min(time_stamps_orig)) / float(max(time_stamps_orig) - min(time_stamps_orig))

                # values to plot are in the profiled workload scale, so the model values need to be rescaled
                # according to the metrics sums..
                vals_model = vals/vals_sum_model[ts_name] * vals_sum_orig[ts_name]
                vals_orig = vals_orig

                plot_dict[ts_name] = {"times": times_norm,
                                      "model_vals": vals_model,
                                      "orig_vals": vals_orig}

            plot_info.append(plot_dict)

            for tt, ts_name in enumerate(total_metrics_model.keys()):
                id_plot += 1
                plt.subplot(n_plots, 1, id_plot)
                plt.subplots_adjust(left=0.2, right=0.8, top=0.9, bottom=0.1)

                if ll == 0:
                    plt.bar(plot_info[ll][ts_name]["times"]-bar_offset, plot_info[ll][ts_name]["model_vals"],
                            bar_w, color=line_color)

                    plt.bar(plot_info[ll][ts_name]["times"], plot_info[ll][ts_name]["orig_vals"],
                            bar_w, color=line_color, hatch='//')
                else:

                    cumul_model_val = np.zeros(n_bins)
                    for l in range(ll):
                        cumul_model_val += plot_info[l][ts_name]["model_vals"]

                    cumul_orig_val = np.zeros(n_bins)
                    for l in range(ll):
                        cumul_orig_val += plot_info[l][ts_name]["orig_vals"]

                    plt.bar(plot_info[ll][ts_name]["times"]-bar_offset, plot_info[ll][ts_name]["model_vals"],
                            bar_w, bottom=cumul_model_val, color=line_color)

                    plt.bar(plot_info[ll][ts_name]["times"], plot_info[ll][ts_name]["orig_vals"],
                            bar_w, bottom=cumul_orig_val, color=line_color, hatch='//')

                plt.ylabel(ts_name)
                plt.xlim(xmin=0, xmax=1)

                # set x-axes labels and ticks as appropriate
                if tt == len(total_metrics_model)-1:
                    plt.xlabel('time')
                else:
                    plt.tick_params(axis='x', which='both', bottom='off', top='off', labelbottom='off')

        plt.show()

    else:
        print "Nothing done! type 'kronos-plot-run -h' for valid options"
