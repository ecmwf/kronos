#!/usr/bin/env python
# (C) Copyright 1996-2017 ECMWF.
# 
# This software is licensed under the terms of the Apache Licence Version 2.0
# which can be obtained at http://www.apache.org/licenses/LICENSE-2.0. 
# In applying this licence, ECMWF does not waive the privileges and immunities 
# granted to it by virtue of its status as an intergovernmental organisation nor
# does it submit to any jurisdiction.

import os
import sys

sys.path.append(os.path.dirname(os.path.dirname(__file__)))

import argparse

from kronos.core import runner
from kronos.core.exceptions_iows import ConfigurationError
from kronos.core.workload_data import WorkloadData
from kronos.core.config.config import Config
from kronos.core.model import KronosModel
from kronos.core.postprocess.run_plotter import RunPlotter

from kronos.io.profile_format import ProfileFormat

class Kronos(object):
    """
    Kronos main class
    """

    def __init__(self, config):

        self.config = config
        self.workloads = None
        self.workload_model = None
        self.model_jobs = None
        self.synthetic_apps = None

        if self.config.verbose:
            print "VERBOSE logging enabled"

    def model(self):
        """
        Depending on the supplied config, ingest data of various types.
        """
        print "\nBeginning data ingestion...\n----------------------------------"

        self.workloads = []
        for filename in self.config.kpf_files:
            with open(os.path.join(self.config.dir_input, filename), 'r') as f:
                self.workloads.append(WorkloadData.from_kpf(ProfileFormat.from_file(f)))

        print "\nIngested workloads: [\n" + ",\n".join(["    {}".format(d.tag) for d in self.workloads]) + "\n]"

        print "\nGenerating model workload...\n----------------------------------"
        self.workload_model = KronosModel(self.workloads, self.config)
        self.workload_model.generate_model()
        self.workload_model.export_synthetic_workload()

        # run_data = RunData(self.config.post_process['dir_sa_run_output'])
        # run_data.print_schedule_summary()

        # if self.config.verbose:
        #     print self.synthetic_apps.verbose_description()

    def export(self):
        print "\nOutputting synthetic app input...\n----------------------------------"
        self.workload_model.export_synthetic_workload()

    def run(self):
        """
        Main execution routine (default if no specific plugin is requested)
        """
        print "\nRun model...\n----------------------------------"
        kronos_runner = runner.factory(self.config.run['type'], self.config)
        kronos_runner.run()

    def postprocess(self, run_dir):
        """
        Postprocess the results of the run
        :return:
        """
        print "\nPostprocess run..\n----------------------------------"
        plotter = RunPlotter(run_dir)
        plotter.plot_run()


if __name__ == "__main__":

    # read other arguments if present..
    parser = argparse.ArgumentParser(description='Kronos software')
    parser.add_argument('configuration_file', type=str)
    parser.add_argument('-m', "--model", help="Generate workload model", action='store_true')
    parser.add_argument('-r', "--run", help="Run the model on HPC", action='store_true')
    parser.add_argument('-p', "--postprocess", help="Postprocess Run results", action='store_true')
    parser.add_argument('-o', "--run_dir", help="Path containing run results")
    args = parser.parse_args()

    # command line keys checks..
    if args.postprocess and not args.run_dir:
        raise ConfigurationError("Specify path of results to post-process: --run_dir=<path-to-results>")
    elif args.postprocess and not os.path.exists(args.run_dir):
        raise ConfigurationError("Path of results {} does not exist".format(args.run_dir))

    try:
        try:

            config = Config(config_path=args.configuration_file)

        except (OSError, IOError) as e:
            print "Error opening input file: {}".format(e)
            print __doc__
            sys.exit(-1)

        except ValueError as e:
            print "Error parsing the supplied input file: {}".format(e)
            sys.exit(-1)

        # And get going!!!
        app = Kronos(config)

        if args.model:
            app.model()
        elif args.run:
            app.run()
        elif args.postprocess:
            app.postprocess(args.run_dir)
        else:
            print "command line parsing error.."
            sys.exit(-1)

    except ConfigurationError as e:
        print "Error in Kronos configuration: {}".format(e)
