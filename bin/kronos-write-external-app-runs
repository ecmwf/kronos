# (C) Copyright 1996-2017 ECMWF.
#
# This software is licensed under the terms of the Apache Licence Version 2.0
# which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
# In applying this licence, ECMWF does not waive the privileges and immunities
# granted to it by virtue of its status as an intergovernmental organisation nor
# does it submit to any jurisdiction.

"""

============================================================================
       **DEVELOPMENT TOOL** - USAGE OF THIS TOOL IS UNSUPPORTED
============================================================================

This tool prepares a kschedule file that contains all the runs to be performed in order
to fill in a parametric "table" of an external application. The results of the run will be used to
best-match a specific synthetic application to a specific run of the external application.
(the tool kronos-find-and-match-app-run will be used on the results of the run)

Arguments:

 - config_params: Json file containing the config_params that will be passed to the synthetic application
   within the kschedule. Each param is a list a nd each run is an entry of the list (so each run corresponds to a
   set of params at a specific index of the param list)

 - job_template: name of the job template file that is written in the kschedule and
   will be used by the synthetic apps when they run (the parameters in the config_params will be passed to the
   job_template to generate actual "submit_scripts")

 - output: name of kschedule to write (optional)

"""
import copy
import sys
import json
import argparse
import itertools

import strict_rfc3339

from kronos.core.time_signal.definitions import time_signal_names
from kronos.io.format_data_handlers.kschedule_data import KScheduleData

sa_template = {
    "depends": None,
    "job_class": None,
    "num_procs": 1,
    "metadata": {
        "job_name": None,
        "workload_name": "raps_workload"
    },
    "config_params": {
        "raps_submit_dir": "path_to_installer"
    },
    "start_delay": 0
}


if __name__ == '__main__':

    # Parser for the required arguments
    parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument("config_params_file", type=str, help="json file containing the params to be passed to the template")
    parser.add_argument("job_template", type=str, help="name of job_template file to use as template")
    parser.add_argument("--output", type=str, help="Path of kschedule which contains matched runs")

    # Print the help if no arguments are passed
    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    # Parse the arguments..
    args = parser.parse_args()

    # name of job_template
    job_template = args.job_template if args.job_template else "unspecified"

    # name of output file
    kschedule_out_file = args.output if args.output else "output.kschedule"

    # Load the data in the config_params json file
    with open(args.config_params_file) as f:
        config_params = json.load(f)

    # Check that all the keys are lists of the same length
    n_non_unrolled_runs = len(config_params.values()[0])
    assert all([len(v) == n_non_unrolled_runs for v in config_params.values()])

    # Go through the parameters and fill the job templates appropriately
    jobs = []
    config_keys = config_params.keys()
    config_values = config_params.values()

    global_com_idx = 0
    for i_values_set in range(n_non_unrolled_runs):

        # print "---------> i_values_set: ", i_values_set
        value_set = [v[i_values_set] if isinstance(v[i_values_set], list) else [v[i_values_set]] for v in config_params.values()]

        # print "values_set ", value_set

        combinations = itertools.product(*value_set)

        for comb in combinations:

            filled_template = copy.deepcopy(sa_template)

            # write the config parameters
            filled_template["config_params"].update({k: comb for k,comb in zip(config_keys, comb)})

            # job_template
            filled_template["job_class"] = job_template

            # set the job_name
            filled_template["metadata"]["job_name"] = "job-{}".format(global_com_idx)

            # sequential job dependency
            filled_template["depends"] = [global_com_idx-1] if global_com_idx else []

            jobs.append(filled_template)

            global_com_idx += 1

    # write output schedule from jobs
    kschedule_data = {
        'jobs': jobs,
        'created': strict_rfc3339.now_to_rfc3339_utcoffset(),
        'uid': 9999,
        'unscaled_metrics_sums': {k: 999 for k in time_signal_names},
        'scaling_factors': {k: 1 for k in time_signal_names}
    }

    kschedule_out = KScheduleData.from_json_data(kschedule_data)
    kschedule_out.write_filename(kschedule_out_file)

